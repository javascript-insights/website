<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Background Fetch - Application Panel</title>
    <link rel="stylesheet" href="/styles.css" />
    <link rel="stylesheet" href="./styles.css" />
    <link rel="icon" type="image/png" href="/static/favicon.png" />
    <style>
        .demo { background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #17a2b8; }
        .tip { background: #e7f3ff; padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #0056b3; }
        #log { background: #1e1e1e; color: #0f0; padding: 15px; border-radius: 8px; font-family: monospace; max-height: 200px; overflow-y: auto; margin: 10px 0; }
        #status { padding: 10px; margin: 10px 0; border-radius: 5px; font-weight: bold; }
        .idle { background: #e2e3e5; color: #383d41; }
        .active { background: #cce5ff; color: #004085; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        button { padding: 10px 20px; margin: 5px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; color: white; }
        #startBtn { background: #17a2b8; }
        #abortBtn { background: #dc3545; }
        #progressBar { width: 100%; height: 20px; background: #e9ecef; border-radius: 10px; overflow: hidden; margin: 10px 0; }
        #progress { height: 100%; background: #17a2b8; transition: width 0.3s; width: 0%; }
    </style>
</head>

<body>
    <h1>üèÉ‚Äç‚ôÇÔ∏è Background Fetch API</h1>
    <nav class="breadcrumb">
        <a href="../../../index.html">JavaScript Insights</a>
        <a href="../../index.html">DevTools</a>
        <a href="../index.html">Application</a>
        <a href="./index.html">Theoretical 3</a>
    </nav>
    <div class="navbar">
        <a href="./index.html">Back</a>
    </div>

    <div class="demo">
        <h2>What is Background Fetch?</h2>
        <p>The <strong>Background Fetch API</strong> lets you download large files even if the user
        navigates away or closes the tab. Unlike <code>fetch()</code>, it continues in the background.</p>
        <p><strong>Use cases:</strong> Downloading movies, podcasts, large datasets, game assets, etc.</p>
    </div>

    <div class="demo">
        <h2>Live Demo</h2>
        <div id="status" class="idle">Status: Idle</div>
        <div id="progressBar"><div id="progress"></div></div>

        <button id="startBtn">Start Background Fetch</button>
        <button id="abortBtn" disabled>Abort Fetch</button>

        <p><small>Fetches local files (including a 5 MB dummy file) to simulate a larger download.</small></p>
    </div>

    <div class="demo">
        <h2>Event Log</h2>
        <div id="log"></div>
    </div>

    <div class="tip">
        <h2>üîß DevTools: Inspecting Background Fetch</h2>
        <ol>
            <li>Open DevTools ‚Üí <strong>Application</strong> ‚Üí <strong>Background services</strong> ‚Üí <strong>Background Fetch</strong></li>
            <li>Click the <strong>record</strong> button (‚è∫) to start recording</li>
            <li>Click "Start Background Fetch" ‚Äî watch events appear in DevTools!</li>
        </ol>
    </div>

    <div class="tip">
        <h2>‚ö†Ô∏è "Offline" in DevTools Won't Stop This!</h2>
        <p>The DevTools <strong>Network ‚Üí Offline</strong> checkbox only emulates offline for the <em>page's</em> own requests
        (<code>fetch()</code>, <code>XMLHttpRequest</code>, etc.). Background Fetch is handled by the <strong>browser process itself</strong>,
        so it bypasses DevTools network emulation entirely.</p>
        <p>To test a failed background fetch, <strong>disconnect your actual network</strong> (disable Wi-Fi / unplug Ethernet).
        This is by design ‚Äî it's what makes Background Fetch resilient!</p>
    </div>

    <div class="tip">
        <h2>üìù Practice Exercises (separate scenarios!)</h2>
        <ol>
            <li><strong>Observe:</strong> Start recording ‚Üí click "Start Background Fetch" ‚Üí watch events in DevTools</li>
            <li><strong>Abort:</strong> Start a new fetch ‚Üí click "Abort" ‚Üí see the abort event (fetch is now cancelled!)</li>
            <li><strong>Navigate away:</strong> Start a new fetch (don't abort!) ‚Üí go to another page ‚Üí come back ‚Üí check the status message at the top</li>
        </ol>
        <p><strong>‚ö†Ô∏è Important:</strong> Abort and navigate-away are <em>separate</em> experiments. If you abort, the fetch is permanently cancelled ‚Äî it will NOT continue.</p>
    </div>

    <script>
        const logEl = document.getElementById('log');
        const progress = document.getElementById('progress');
        const abortBtn = document.getElementById('abortBtn');
        let currentFetch = null;

        // Helper: append a timestamped message to the log
        function log(msg) {
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.textContent = `[${time}] ${msg}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
            console.log(`[Background Fetch] [${time}] ${msg}`);
        }

        // Helper: update the status bar
        function setStatus(msg, cls) {
            const el = document.getElementById('status');
            el.textContent = 'Status: ' + msg;
            el.className = cls;
        }

        // 1) Register the service worker
        navigator.serviceWorker.register('background-fetch-service-worker.js')
            .then(() => log('‚úÖ Service Worker registered'))
            .catch(err => log('‚ùå SW registration failed: ' + err));

        // 2) Listen for messages from the service worker
        navigator.serviceWorker.addEventListener('message', ({ data }) => {
            if (data.type === 'bgfetch-success') {
                log('‚úÖ Fetch completed!');   setStatus('Completed!', 'success');
            } else if (data.type === 'bgfetch-fail') {
                log('‚ùå Fetch failed');        setStatus('Failed', 'error');
            } else if (data.type === 'bgfetch-abort') {
                log('üõë Fetch aborted');       setStatus('Aborted', 'error');
            }
            abortBtn.disabled = true;
            progress.style.width = data.type === 'bgfetch-success' ? '100%' : '0%';
        });

        // 3) Start a background fetch
        document.getElementById('startBtn').addEventListener('click', async () => {
            if (!('BackgroundFetchManager' in self)) {
                return log('‚ùå Background Fetch not supported ‚Äî try Chrome/Edge');
            }
            try {
                const sw = await navigator.serviceWorker.ready;
                const id = 'demo-fetch-' + Date.now();

                // Fetch local files (the 5 MB file makes it take a moment)
                currentFetch = await sw.backgroundFetch.fetch(id, [
                    'index.html', 'styles.css', 'getstarted.json', 'large-demo-file.bin'
                ], { title: 'Demo Background Fetch', downloadTotal: 0 });

                log('‚úÖ Fetch started ‚Äî ID: ' + id);
                setStatus('Fetching...', 'active');
                abortBtn.disabled = false;

                // Monitor progress
                currentFetch.addEventListener('progress', () => {
                    const { downloaded, downloadTotal, result, failureReason } = currentFetch;
                    const pct = downloadTotal ? Math.round(downloaded / downloadTotal * 100) : 100;
                    progress.style.width = pct + '%';
                    log(`Progress: ${downloaded} bytes (${pct}%)`);

                    if (result === 'success') {
                        log('‚úÖ Completed!'); setStatus('Completed!', 'success'); abortBtn.disabled = true;
                    } else if (result === 'failure') {
                        log('‚ùå Failed: ' + failureReason); setStatus('Failed', 'error'); abortBtn.disabled = true;
                    }
                });
            } catch (err) {
                log('‚ùå Error: ' + err.message);
                setStatus('Failed: ' + err.message, 'error');
            }
        });

        // 4) Abort the current fetch
        abortBtn.addEventListener('click', async () => {
            if (!currentFetch) return;
            try { await currentFetch.abort(); } catch (e) { log('Abort error: ' + e.message); }
            log('üõë Aborted'); setStatus('Aborted', 'error'); abortBtn.disabled = true;
        });

        // 5) On page load, check if a previous background fetch completed while we were away
        (async () => {
            if (!('BackgroundFetchManager' in self)) return;
            const sw = await navigator.serviceWorker.ready;
            const ids = await sw.backgroundFetch.getIds();
            if (ids.length > 0) {
                log('üìã Found previous background fetches: ' + ids.join(', '));
                for (const id of ids) {
                    const bgFetch = await sw.backgroundFetch.get(id);
                    log(`  ‚Üí ${id}: result=${bgFetch.result || 'still running'}, downloaded=${bgFetch.downloaded} bytes`);
                    if (bgFetch.result === 'success') {
                        setStatus('Previous fetch completed while you were away!', 'success');
                    } else if (bgFetch.result === '') {
                        setStatus('Previous fetch is still running!', 'active');
                        progress.style.width = bgFetch.downloadTotal
                            ? Math.round(bgFetch.downloaded / bgFetch.downloadTotal * 100) + '%' : '50%';
                    }
                }
            } else {
                log('No previous background fetches found.');
            }
        })();

        log('Page loaded. Ready to fetch!');
    </script>
</body>

</html>