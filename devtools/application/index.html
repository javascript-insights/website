<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JavaScript Insights</title>
  <link rel="stylesheet" href="/styles.css" />
  <link rel="icon" type="image/png" href="/static/favicon.png" />
</head>

<body>
  <h1>Application</h1>
  <nav class="breadcrumb">
    <a href="../../index.html">JavaScript Insights</a>
    <a href="../index.html">DevTools</a>
    <a href="./index.html">Application</a>
  </nav>
  <div class="navbar">
    <a href="../index.html">Back</a>
    <a href="./theoretical-1/index.html">Theoretical 1</a>
    <a href="./theoretical-2/index.html">Theoretical 2</a>
    <a href="./theoretical-3/index.html">Theoretical 3</a>
    <a href="./theoretical-4/index.html">Theoretical 4</a>
    <a href="./hands-on-1/index.html">Hands-On 1</a>
    <a href="./hands-on-2/index.html">Hands-On 2</a>
    <a href="./hands-on-3/index.html">Hands-On 3</a>
    <a href="./hands-on-4/index.html">Hands-On 4</a>
  </div>

  <p>Use the Application tool to manage storage for web app pages </p>
  <p>- it's like being a digital hoarder, but organized!</p>
  <p><u>We've got:</u></p>
  <ul>
    <li>üìú Manifests (fancy todo lists for your app)</li>
    <li>üë∑ Service Workers (tiny digital employees working 24/7)</li>
    <li>üì¶ Local Storage (where your app keeps its secret stash)</li>
    <li>üç™ Cookies (nom nom nom)</li>
    <li>üíæ Cache Storage (like your browser's mini-fridge)</li>
    <li>üîÑ Background Services (the ninjas working behind the scenes)</li>
  </ul>

  <h2>Service Workers:</h2>
  <p>
    They act as proxy servers between web applications, the browser, and the network. They primarily enable offline
    experiences, caching, push notifications, and background sync. Service workers intercept network requests, allowing
    control over how the application behaves in various situations, especially when the network is unavailable. They
    operate in a separate thread, without DOM access, and are designed to be fully asynchronous.
  </p>

  <h2>Background Workers (Web Workers):</h2>
  <p>
    They are general-purpose background threads designed to run CPU-intensive tasks without blocking the main thread,
    ensuring a responsive user interface. Background workers facilitate parallel processing, allowing complex
    computations or data processing to occur independently. They do not intercept network requests; instead, the main
    thread explicitly sends messages to them. Their lifespan is tied to the tab or page they are created in, terminating
    when the tab is closed.
  </p>

  <h3>Comparison:</h3>
  <table border="1">
    <tr>
      <th>Feature</th>
      <th>Service Worker</th>
      <th>Background Worker (Web Worker)</th>
    </tr>
    <tr>
      <td>Purpose</td>
      <td>Network proxy, offline support, caching, push notifications</td>
      <td>Background processing, offloading CPU-intensive tasks</td>
    </tr>
    <tr>
      <td>Network</td>
      <td>Intercepts network requests</td>
      <td>Does not intercept network requests</td>
    </tr>
    <tr>
      <td>DOM Access</td>
      <td>No DOM access</td>
      <td>No DOM access</td>
    </tr>
    <tr>
      <td>Lifespan</td>
      <td>Independent of the page/tab</td>
      <td>Tied to the page/tab</td>
    </tr>
    <tr>
      <td>Use Cases</td>
      <td>PWAs, offline functionality, push notifications</td>
      <td>Complex calculations, data processing, real-time applications</td>
    </tr>
    <tr>
      <td>Communication</td>
      <td>Intercepts fetch requests, listens for push events</td>
      <td>Receives messages via postMessage</td>
    </tr>
  </table>

  <h3>Service Worker Example:</h3>
  <pre><code>
// In your main.js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(registration => console.log('SW registered'))
    .catch(error => console.log('SW registration failed'));
}

// In sw.js
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open('v1').then(cache => {
      return cache.addAll([
        '/',
        '/styles.css',
        '/app.js'
      ]);
    })
  );
});

self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => response || fetch(event.request))
  );
});
  </code></pre>

  <details>
    <summary>When does the <code>install</code> event fire?</summary>
    <div style="padding: 10px; margin-top: 5px;">
      <p>The <code>install</code> event fires <strong>immediately after the service worker is successfully downloaded and parsed</strong> by the browser, triggered by the <code>navigator.serviceWorker.register('/sw.js')</code> call.</p>
      <p>The sequence is:</p>
      <ol>
        <li><code>register()</code> is called ‚Üí browser downloads <code>sw.js</code></li>
        <li>The SW is parsed successfully ‚Üí <strong><code>install</code> event fires</strong></li>
        <li><code>event.waitUntil()</code> keeps the SW in the "installing" phase until all <code>cache.addAll()</code> promises resolve</li>
        <li>If caching succeeds ‚Üí SW moves to "waiting" (or "activated" if no previous SW exists)</li>
        <li>If caching fails (e.g., any resource in <code>addAll</code> 404s) ‚Üí installation <strong>fails</strong>, SW is discarded</li>
      </ol>
      <p><strong>Key points:</strong></p>
      <ul>
        <li><strong>First visit:</strong> <code>install</code> fires right after registration, then the SW activates (since there's no previous version).</li>
        <li><strong>Subsequent visits:</strong> <code>install</code> fires again <strong>only if <code>sw.js</code> has changed</strong> (even a single byte difference). The new SW then waits until all tabs using the old SW are closed before activating.</li>
        <li><strong><code>install</code> does NOT fire</strong> if the browser's byte-compared cache of <code>sw.js</code> matches the fetched version ‚Äî the existing SW is reused as-is.</li>
      </ul>
    </div>
  </details>

  <details>
    <summary>When does the <code>fetch</code> event fire?</summary>
    <div style="padding: 10px; margin-top: 5px;">
      <p>The <code>fetch</code> event fires on <strong>every network request</strong> made by pages the service worker <strong>controls</strong> ‚Äî but with an important caveat:</p>
      <p><strong>Not immediately on first visit.</strong> Even though the SW installs and activates on the first visit, it <strong>does not control the page that registered it</strong>. The page must be <strong>navigated to again</strong> (refresh or revisit) for the SW to intercept its requests.</p>
      <p>The timeline is:</p>
      <ol>
        <li><strong>First visit</strong> ‚Üí SW registers, installs, activates ‚Äî but <code>fetch</code> does <strong>NOT</strong> fire. All requests go straight to the network.</li>
        <li><strong>Second visit (or refresh)</strong> ‚Üí the SW now controls the page ‚Üí <code>fetch</code> fires for <strong>every request</strong>: the HTML page itself, CSS, JS, images, fonts, API calls ‚Äî everything.</li>
      </ol>
      <p>For each intercepted request, the code:</p>
      <ol>
        <li>Checks the cache for a match ‚Üí if found, returns it (no network call)</li>
        <li>If not cached ‚Üí falls back to a normal <code>fetch()</code> from the network</li>
      </ol>
      <p><strong>Exceptions</strong> ‚Äî the fetch event does <strong>not</strong> fire for:</p>
      <ul>
        <li>Requests made before the SW controls the page</li>
        <li>Requests from other origins (cross-origin) unless explicitly handled</li>
        <li>The SW script file itself (<code>sw.js</code>)</li>
      </ul>
    </div>
  </details>

  <h3>Web Worker Example:</h3>
  <pre><code>
// In your main.js
const worker = new Worker('worker.js');

worker.postMessage({ data: 'Start calculation' });

worker.onmessage = function(e) {
  console.log('Result:', e.data);
};

// In worker.js
self.onmessage = function(e) {
  // Heavy computation here
  const result = e.data.data + ' completed';
  self.postMessage(result);
};
  </code></pre>

  <p>
    While both operate in background threads, their roles are distinct. Service workers enhance web application
    capabilities related to network requests and offline access, whereas background workers improve performance by
    handling computationally intensive tasks separately from the main thread.
  </p>

  <div style="display: flex; justify-content: flex-start; max-width: 600px;">
    <img src="https://media.giphy.com/media/DpNrB4a210Qg0/giphy.gif" alt="Typing cat gif" style="width:100%">
  </div>
  </p>
</body>

</html>