<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JavaScript Insights</title>
  <link rel="stylesheet" href="/styles.css" />
  <link rel="icon" type="image/png" href="/static/favicon.png" />
</head>

<body>
  <h1>Performance</h1>
  <nav class="breadcrumb">
    <a href="../../index.html">JavaScript Insights</a>
    <a href="../index.html">DevTools</a>
    <a href="./index.html">Performance</a>
  </nav>
  <div class="navbar">
    <a href="../index.html">Back</a>
    <a href="./theoretical/index.html">Theoretical</a>
    <a href="./hands-on/index.html">Hands On</a>
  </div>

  <p>The Performance panel lets you record CPU performance profiles of your web applications. Analyze profiles to find
    potential performance bottlenecks and ways you can optimize resource use.</p>

  <p>Use the Performance panel to do the following:</p>

  <ul>
    <li>Record a performance profile.</li>
    <li>Change capture settings.</li>
    <li>Analyze a performance report.</li>
  </ul>

  <p>Common advice for keeping JavaScript apps fast includes:</p>
  <ul>
    <li>Don't block the main thread.</li>
    <li>Break up long tasks.</li>
  </ul>
  <p>Shipping less JavaScript can help, but it's not always enough. To optimize tasks, you need to understand what tasks
    are and how the browser handles them.</p>
  <p>A task is any piece of work the browser does, such as rendering, parsing HTML/CSS, and running JavaScript.
    JavaScript tasks impact performance by queuing tasks during startup and responding to interactions.</p>
  <p>The main thread processes one task at a time. Tasks longer than 50ms are long tasks, and their blocking period
    affects user interactions. Breaking up long tasks into smaller ones allows the browser to respond to higher-priority
    work sooner.</p>
  <img src="./static/a-depiction-how-breaking-999bc2dd02872_960.png"
    alt="A depiction of how breaking up long tasks can improve performance" style="width: 600px;" />
  <p>By breaking up tasks, the browser can handle user interactions more efficiently, making the interface feel more
    responsive.</p>

  <ol>
    <h3>Work...</h3>
    <script>
      function mineBitcoin() {
        let result = 0;
        for (let i = 0; i < 100000000; i++) {
          result += i;
        }
        return result;
      }
    </script>
    <li>


      <strong>Using console.time and console.timeEnd</strong>
      <p>This method is straightforward and useful for measuring the time taken by a specific block of code.</p>
      <script>
        console.time('MyFunction1');
        // Your code block
        mineBitcoin();
        console.timeEnd('MyFunction1');
      </script>
    </li>
    <li>
      <strong>Using the Performance API</strong>
      <p>The Performance API provides more detailed and precise measurements.</p>
      <script>
        // Start measuring
        performance.mark('start');

        // Your code block
        mineBitcoin();

        // End measuring
        performance.mark('end');

        // Measure the duration
        performance.measure('MyFunction2', 'start', 'end');

        // Log the result
        const measure = performance.getEntriesByName('MyFunction2')[0];
        console.log(`MyFunction2 took ${measure.duration} milliseconds`);
      </script>
    </li>
    <li>
      <strong>Using performance.now</strong>
      <p>For high-resolution time stamps, performance.now is a great option.</p>
      <script>
        const start = performance.now();

        // Your code block
        mineBitcoin();

        const end = performance.now();
        console.log(`MyFunction3 took ${end - start} milliseconds`);
      </script>
    </li>
  </ol>

</body>

</html>